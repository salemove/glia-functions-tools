<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/retry.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/retry.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Retry mechanism for API requests
 * 
 * Provides configurable retry strategies with exponential backoff
 * and circuit breaker functionality for the Glia API client.
 */

import { NetworkError, RateLimitError } from './errors.js';

/**
 * Default retry configuration
 */
export const DEFAULT_RETRY_CONFIG = {
  maxRetries: 3,
  initialDelayMs: 500,
  maxDelayMs: 10000,
  backoffFactor: 2,
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
  retryableNetworkErrors: ['ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED', 'NETWORK_ERROR'],
  retryStrategy: 'exponential', // 'exponential', 'linear', or 'fixed'
};

/**
 * Circuit breaker state for tracking persistent failures
 */
export class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.resetTimeoutMs = options.resetTimeoutMs || 30000;
    this.halfOpenMaxCalls = options.halfOpenMaxCalls || 1;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failures = 0;
    this.halfOpenCalls = 0;
    this.lastFailureTime = null;
  }

  /**
   * Record a successful call
   */
  recordSuccess() {
    if (this.state === 'HALF_OPEN') {
      this.halfOpenCalls++;
      
      // If we've had enough successful calls in half-open state, close the circuit
      if (this.halfOpenCalls >= this.halfOpenMaxCalls) {
        this.close();
      }
    } else if (this.state === 'CLOSED') {
      // Reset failures on successful calls when closed
      this.failures = 0;
    }
  }

  /**
   * Record a failed call
   */
  recordFailure() {
    this.lastFailureTime = Date.now();
    
    if (this.state === 'HALF_OPEN') {
      // If we fail during half-open state, go back to open
      this.open();
    } else if (this.state === 'CLOSED') {
      this.failures++;
      
      // Open the circuit if we've hit the threshold
      if (this.failures >= this.failureThreshold) {
        this.open();
      }
    }
  }

  /**
   * Check if the circuit allows a call
   * @returns {boolean} - Whether the call should be allowed
   */
  allowRequest() {
    // Always allow in closed state
    if (this.state === 'CLOSED') {
      return true;
    }
    
    // Allow limited calls in half-open state
    if (this.state === 'HALF_OPEN') {
      return this.halfOpenCalls &lt; this.halfOpenMaxCalls;
    }
    
    // In open state, check if we should transition to half-open
    if (this.state === 'OPEN' &amp;&amp; this.lastFailureTime) {
      const elapsed = Date.now() - this.lastFailureTime;
      
      // After reset timeout, transition to half-open
      if (elapsed >= this.resetTimeoutMs) {
        this.halfOpen();
        return this.halfOpenCalls &lt; this.halfOpenMaxCalls;
      }
    }
    
    // Default: don't allow the request
    return false;
  }

  /**
   * Open the circuit (block all calls)
   */
  open() {
    this.state = 'OPEN';
    this.lastFailureTime = Date.now();
  }

  /**
   * Set to half-open state (allow limited calls)
   */
  halfOpen() {
    this.state = 'HALF_OPEN';
    this.halfOpenCalls = 0;
  }

  /**
   * Close the circuit (allow all calls)
   */
  close() {
    this.state = 'CLOSED';
    this.failures = 0;
    this.halfOpenCalls = 0;
  }

  /**
   * Get the current circuit state
   * @returns {string} - 'CLOSED', 'OPEN', or 'HALF_OPEN'
   */
  getState() {
    return this.state;
  }
}

/**
 * Sleep for a specified number of milliseconds
 * @param {number} ms - Milliseconds to sleep
 * @returns {Promise} - Promise that resolves after the delay
 */
export const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Calculate delay time using exponential backoff
 * @param {number} retryCount - The current retry attempt number (0-based)
 * @param {Object} config - Retry configuration
 * @returns {number} - Delay in milliseconds
 */
export const calculateBackoffDelay = (retryCount, config) => {
  if (config.retryStrategy === 'fixed') {
    return config.initialDelayMs;
  }
  
  if (config.retryStrategy === 'linear') {
    return Math.min(
      config.initialDelayMs * (retryCount + 1),
      config.maxDelayMs
    );
  }
  
  // Default: exponential
  const delay = Math.min(
    config.initialDelayMs * Math.pow(config.backoffFactor, retryCount),
    config.maxDelayMs
  );
  
  // Add jitter (Â±20%) to prevent thundering herd
  const jitter = delay * 0.2 * (Math.random() - 0.5);
  return Math.max(config.initialDelayMs, delay + jitter);
};

/**
 * Check if an error or status code is retryable
 * @param {Error|number} errorOrStatus - Error object or HTTP status code
 * @param {Object} config - Retry configuration
 * @returns {boolean} - Whether the error/status is retryable
 */
export const isRetryable = (errorOrStatus, config) => {
  // Handle HTTP status codes
  if (typeof errorOrStatus === 'number') {
    return config.retryableStatusCodes.includes(errorOrStatus);
  }
  
  // Handle errors
  if (errorOrStatus instanceof Error) {
    // Rate limit errors are always retryable
    if (errorOrStatus instanceof RateLimitError) {
      return true;
    }
    
    // Network errors are potentially retryable
    if (errorOrStatus instanceof NetworkError) {
      return errorOrStatus.retryable === true;
    }
    
    // Check error codes from underlying network errors
    const errorCode = errorOrStatus.code || 
                     (errorOrStatus.cause &amp;&amp; errorOrStatus.cause.code);
    if (errorCode &amp;&amp; config.retryableNetworkErrors.includes(errorCode)) {
      return true;
    }
    
    // Look for specific error messages that indicate retryable conditions
    const errorMessage = errorOrStatus.message.toLowerCase();
    return errorMessage.includes('timeout') || 
           errorMessage.includes('network') ||
           errorMessage.includes('connection') ||
           errorMessage.includes('temporary');
  }
  
  return false;
};

/**
 * Execute a function with retry logic
 * @param {Function} fn - The function to execute (returns a promise)
 * @param {Object} options - Retry options
 * @param {Object} options.retryConfig - Retry configuration (extends DEFAULT_RETRY_CONFIG)
 * @param {CircuitBreaker} options.circuitBreaker - Optional circuit breaker
 * @param {Function} options.onRetry - Called before each retry attempt
 * @returns {Promise&lt;any>} - The result of the function
 */
export const withRetry = async (fn, options = {}) => {
  const config = { ...DEFAULT_RETRY_CONFIG, ...(options.retryConfig || {}) };
  const circuitBreaker = options.circuitBreaker;
  const onRetry = options.onRetry || (() => {});
  const contextInfo = options.context || {};
  
  // Check circuit breaker first
  if (circuitBreaker &amp;&amp; !circuitBreaker.allowRequest()) {
    throw new NetworkError(
      'Circuit breaker open: too many recent failures',
      { circuitState: circuitBreaker.getState() },
      { statusCode: 0 }
    );
  }
  
  let lastError;
  
  // Try the initial request and up to maxRetries additional attempts
  for (let attempt = 0; attempt &lt;= config.maxRetries; attempt++) {
    try {
      // Execute the function
      const result = await fn();
      
      // Record success in circuit breaker
      if (circuitBreaker) {
        circuitBreaker.recordSuccess();
      }
      
      return result;
    } catch (error) {
      lastError = error;
      
      // Don't retry if we've exhausted attempts
      if (attempt >= config.maxRetries) {
        break;
      }
      
      // Don't retry if the error is not retryable
      if (!isRetryable(error, config)) {
        break;
      }
      
      // For rate limit errors, use retry-after if provided
      let delayMs;
      if (error instanceof RateLimitError &amp;&amp; error.retryAfter) {
        delayMs = error.retryAfter * 1000;
      } else {
        delayMs = calculateBackoffDelay(attempt, config);
      }
      
      // Call the onRetry callback with relevant info
      await onRetry({
        error,
        attempt: attempt + 1,
        delayMs,
        ...contextInfo
      });
      
      // Wait before retrying
      await sleep(delayMs);
    }
  }
  
  // If we got here, all retries failed
  if (circuitBreaker) {
    circuitBreaker.recordFailure();
  }
  
  throw lastError;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-api.html">api</a></li><li><a href="module-config.html">config</a></li></ul><h3>Classes</h3><ul><li><a href="ApiError.html">ApiError</a></li><li><a href="AuthenticationError.html">AuthenticationError</a></li><li><a href="BaseCommand_BaseCommand.html">BaseCommand</a></li><li><a href="CircuitBreaker.html">CircuitBreaker</a></li><li><a href="ConfigurationError.html">ConfigurationError</a></li><li><a href="FunctionError.html">FunctionError</a></li><li><a href="GliaError.html">GliaError</a></li><li><a href="NetworkDetector.html">NetworkDetector</a></li><li><a href="NetworkError.html">NetworkError</a></li><li><a href="OfflineManager.html">OfflineManager</a></li><li><a href="OperationQueue.html">OperationQueue</a></li><li><a href="PersistentCacheStorage.html">PersistentCacheStorage</a></li><li><a href="RateLimitError.html">RateLimitError</a></li><li><a href="ResponseCache.html">ResponseCache</a></li><li><a href="ValidationError.html">ValidationError</a></li><li><a href="module-api.html">api</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIAuth">CLIAuth</a></li><li><a href="global.html#CLIBuildMenu">CLIBuildMenu</a></li><li><a href="global.html#CLICreateProfile">CLICreateProfile</a></li><li><a href="global.html#CLIDeleteProfile">CLIDeleteProfile</a></li><li><a href="global.html#CLIDeployFunction">CLIDeployFunction</a></li><li><a href="global.html#CLIDevFunction">CLIDevFunction</a></li><li><a href="global.html#CLIFunctionDetailsMenu">CLIFunctionDetailsMenu</a></li><li><a href="global.html#CLIFunctionInvoke">CLIFunctionInvoke</a></li><li><a href="global.html#CLIFunctionLogs">CLIFunctionLogs</a></li><li><a href="global.html#CLIFunctionVersion">CLIFunctionVersion</a></li><li><a href="global.html#CLIFunctionVersions">CLIFunctionVersions</a></li><li><a href="global.html#CLIInitProject">CLIInitProject</a></li><li><a href="global.html#CLIListFunctions">CLIListFunctions</a></li><li><a href="global.html#CLIListProfiles">CLIListProfiles</a></li><li><a href="global.html#CLIMainMenu">CLIMainMenu</a></li><li><a href="global.html#CLIManageEnvVars">CLIManageEnvVars</a></li><li><a href="global.html#CLINewFunction">CLINewFunction</a></li><li><a href="global.html#CLINewVersion">CLINewVersion</a></li><li><a href="global.html#CLIProfileMenu">CLIProfileMenu</a></li><li><a href="global.html#CLISetup">CLISetup</a></li><li><a href="global.html#CLISwitchProfile">CLISwitchProfile</a></li><li><a href="global.html#CLIUpdateEnvironment">CLIUpdateEnvironment</a></li><li><a href="global.html#CLIUpdateFunction">CLIUpdateFunction</a></li><li><a href="global.html#DEFAULT_CACHE_CONFIG">DEFAULT_CACHE_CONFIG</a></li><li><a href="global.html#DEFAULT_OFFLINE_CONFIG">DEFAULT_OFFLINE_CONFIG</a></li><li><a href="global.html#DEFAULT_RETRY_CONFIG">DEFAULT_RETRY_CONFIG</a></li><li><a href="global.html#calculateBackoffDelay">calculateBackoffDelay</a></li><li><a href="global.html#createAndDeployVersion">createAndDeployVersion</a></li><li><a href="global.html#createBearerToken">createBearerToken</a></li><li><a href="global.html#createFromTemplate">createFromTemplate</a></li><li><a href="global.html#createFunction">createFunction</a></li><li><a href="global.html#createProjectFromTemplate">createProjectFromTemplate</a></li><li><a href="global.html#dev">dev</a></li><li><a href="global.html#displayRequestDetails">displayRequestDetails</a></li><li><a href="global.html#displayTroubleshootingHints">displayTroubleshootingHints</a></li><li><a href="global.html#displayValidationDetails">displayValidationDetails</a></li><li><a href="global.html#fetchAllLogs">fetchAllLogs</a></li><li><a href="global.html#fetchGfLogs">fetchGfLogs</a></li><li><a href="global.html#fetchLogs">fetchLogs</a></li><li><a href="global.html#formatEnvVars">formatEnvVars</a></li><li><a href="global.html#formatErrorForDisplay">formatErrorForDisplay</a></li><li><a href="global.html#getAllFilesInDir">getAllFilesInDir</a></li><li><a href="global.html#getProjectTemplate">getProjectTemplate</a></li><li><a href="global.html#getTemplate">getTemplate</a></li><li><a href="global.html#getTemplateDefaultVars">getTemplateDefaultVars</a></li><li><a href="global.html#getTemplateEnvVars">getTemplateEnvVars</a></li><li><a href="global.html#handleError">handleError</a></li><li><a href="global.html#initCommand">initCommand</a></li><li><a href="global.html#interactiveEnvVars">interactiveEnvVars</a></li><li><a href="global.html#invokeFunction">invokeFunction</a></li><li><a href="global.html#isRetryable">isRetryable</a></li><li><a href="global.html#listEnvVars">listEnvVars</a></li><li><a href="global.html#listFunctions">listFunctions</a></li><li><a href="global.html#listProjectTemplates">listProjectTemplates</a></li><li><a href="global.html#listTemplates">listTemplates</a></li><li><a href="global.html#listTemplatesCommand">listTemplatesCommand</a></li><li><a href="global.html#main">main</a></li><li><a href="global.html#makeApiRequest">makeApiRequest</a></li><li><a href="global.html#onInvoke">onInvoke</a></li><li><a href="global.html#parseAndValidateJson">parseAndValidateJson</a></li><li><a href="global.html#parseVariables">parseVariables</a></li><li><a href="global.html#replaceVariables">replaceVariables</a></li><li><a href="global.html#routeCommand">routeCommand</a></li><li><a href="global.html#runCLI">runCLI</a></li><li><a href="global.html#showDebug">showDebug</a></li><li><a href="global.html#showError">showError</a></li><li><a href="global.html#showInfo">showInfo</a></li><li><a href="global.html#showSuccess">showSuccess</a></li><li><a href="global.html#showWarning">showWarning</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#updateEnvVars">updateEnvVars</a></li><li><a href="global.html#updateFunction">updateFunction</a></li><li><a href="global.html#validateApiConfiguration">validateApiConfiguration</a></li><li><a href="global.html#validateDateString">validateDateString</a></li><li><a href="global.html#validateEnvironmentVariables">validateEnvironmentVariables</a></li><li><a href="global.html#validateFilePath">validateFilePath</a></li><li><a href="global.html#validateFunctionId">validateFunctionId</a></li><li><a href="global.html#validateFunctionName">validateFunctionName</a></li><li><a href="global.html#validateInput">validateInput</a></li><li><a href="global.html#validateTemplateVariables">validateTemplateVariables</a></li><li><a href="global.html#withRetry">withRetry</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
